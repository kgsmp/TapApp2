<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Sampler</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    function MobileSampler() {
      const [pads, setPads] = useState(Array(16).fill(null));
      const [selectedPad, setSelectedPad] = useState(null);
      const [isRecording, setIsRecording] = useState(false);
      const [playingPads, setPlayingPads] = useState(new Set());
      const [editingPad, setEditingPad] = useState(null);
      const [editParams, setEditParams] = useState({ volume: 1, trimStart: 0, trimEnd: 1, normalize: false });
      const [mutedPads, setMutedPads] = useState(new Set());
      const [isRecordingTrack, setIsRecordingTrack] = useState(false);
      const [showExportModal, setShowExportModal] = useState(false);
      const [exportFormat, setExportFormat] = useState('wav');
      const [exportSampleRate, setExportSampleRate] = useState(48000);
      
      const mediaRecorder = useRef(null);
      const audioChunks = useRef([]);
      const audioContextRef = useRef(null);
      const audioElements = useRef({});
      const trackRecorder = useRef(null);
      const trackStream = useRef(null);
      const fileInputRef = useRef(null);

      useEffect(() => {
        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        return () => {
          if (audioContextRef.current) {
            audioContextRef.current.close();
          }
        };
      }, []);

      const startRecording = async () => {
        if (selectedPad === null) {
          alert('Please select a pad first');
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder.current = new MediaRecorder(stream);
          audioChunks.current = [];

          mediaRecorder.current.ondataavailable = (e) => {
            audioChunks.current.push(e.data);
          };

          mediaRecorder.current.onstop = async () => {
            const blob = new Blob(audioChunks.current, { type: 'audio/webm' });
            const arrayBuffer = await blob.arrayBuffer();
            
            const newPads = [...pads];
            newPads[selectedPad] = {
              original: arrayBuffer,
              processed: arrayBuffer,
              volume: 1,
              trimStart: 0,
              trimEnd: 1,
              normalize: false
            };
            setPads(newPads);
            
            stream.getTracks().forEach(track => track.stop());
          };

          mediaRecorder.current.start();
          setIsRecording(true);
        } catch (err) {
          alert('Microphone access denied');
        }
      };

      const stopRecording = () => {
        if (mediaRecorder.current && isRecording) {
          mediaRecorder.current.stop();
          setIsRecording(false);
        }
      };

      const handleFileUpload = async (e) => {
        if (selectedPad === null) {
          alert('Please select a pad first');
          return;
        }

        const file = e.target.files[0];
        if (!file) return;

        const arrayBuffer = await file.arrayBuffer();
        
        const newPads = [...pads];
        newPads[selectedPad] = {
          original: arrayBuffer,
          processed: arrayBuffer,
          volume: 1,
          trimStart: 0,
          trimEnd: 1,
          normalize: false
        };
        setPads(newPads);
        
        e.target.value = '';
      };

      const processAudio = async (padData, params) => {
        const audioBuffer = await audioContextRef.current.decodeAudioData(padData.original.slice(0));
        const { trimStart, trimEnd, volume, normalize } = params;
        
        const startSample = Math.floor(trimStart * audioBuffer.length);
        const endSample = Math.floor(trimEnd * audioBuffer.length);
        const newLength = endSample - startSample;
        
        const processedBuffer = audioContextRef.current.createBuffer(
          audioBuffer.numberOfChannels,
          newLength,
          audioBuffer.sampleRate
        );

        for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
          const inputData = audioBuffer.getChannelData(ch);
          const outputData = processedBuffer.getChannelData(ch);
          
          let max = 0;
          for (let i = startSample; i < endSample; i++) {
            max = Math.max(max, Math.abs(inputData[i]));
          }
          
          const normFactor = normalize && max > 0 ? 1 / max : 1;
          
          for (let i = 0; i < newLength; i++) {
            outputData[i] = inputData[startSample + i] * normFactor * volume;
          }
        }

        const offlineContext = new OfflineAudioContext(
          processedBuffer.numberOfChannels,
          processedBuffer.length,
          processedBuffer.sampleRate
        );
        
        const source = offlineContext.createBufferSource();
        source.buffer = processedBuffer;
        source.connect(offlineContext.destination);
        source.start();
        
        const rendered = await offlineContext.startRendering();
        const wavBlob = audioBufferToWav(rendered);
        return await wavBlob.arrayBuffer();
      };

      const audioBufferToWav = (buffer, sampleRate = null) => {
        const targetRate = sampleRate || buffer.sampleRate;
        const numChannels = buffer.numberOfChannels;
        const format = 1;
        const bitDepth = 16;
        
        const bytesPerSample = bitDepth / 8;
        const blockAlign = numChannels * bytesPerSample;
        
        let data;
        if (targetRate !== buffer.sampleRate) {
          const ratio = targetRate / buffer.sampleRate;
          const newLength = Math.floor(buffer.length * ratio);
          data = new Float32Array(newLength * numChannels);
          
          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = buffer.getChannelData(ch);
            for (let i = 0; i < newLength; i++) {
              const srcIndex = i / ratio;
              const srcIndexFloor = Math.floor(srcIndex);
              const srcIndexCeil = Math.min(srcIndexFloor + 1, buffer.length - 1);
              const t = srcIndex - srcIndexFloor;
              const interpolated = channelData[srcIndexFloor] * (1 - t) + channelData[srcIndexCeil] * t;
              data[i * numChannels + ch] = interpolated;
            }
          }
        } else {
          data = new Float32Array(buffer.length * numChannels);
          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = buffer.getChannelData(ch);
            for (let i = 0; i < buffer.length; i++) {
              data[i * numChannels + ch] = channelData[i];
            }
          }
        }
        
        const dataLength = data.length * bytesPerSample;
        const arrayBuffer = new ArrayBuffer(44 + dataLength);
        const view = new DataView(arrayBuffer);
        
        const writeString = (offset, string) => {
          for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
          }
        };
        
        writeString(0, 'RIFF');
        view.setUint32(4, 36 + dataLength, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, format, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, targetRate, true);
        view.setUint32(28, targetRate * blockAlign, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, bitDepth, true);
        writeString(36, 'data');
        view.setUint32(40, dataLength, true);
        
        let offset = 44;
        for (let i = 0; i < data.length; i++) {
          const sample = Math.max(-1, Math.min(1, data[i]));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
          offset += 2;
        }
        
        return new Blob([arrayBuffer], { type: 'audio/wav' });
      };

      const audioBufferToAiff = (buffer, sampleRate = null) => {
        const targetRate = sampleRate || buffer.sampleRate;
        const numChannels = buffer.numberOfChannels;
        const bitDepth = 16;
        const bytesPerSample = bitDepth / 8;
        
        let data;
        if (targetRate !== buffer.sampleRate) {
          const ratio = targetRate / buffer.sampleRate;
          const newLength = Math.floor(buffer.length * ratio);
          data = new Float32Array(newLength * numChannels);
          
          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = buffer.getChannelData(ch);
            for (let i = 0; i < newLength; i++) {
              const srcIndex = i / ratio;
              const srcIndexFloor = Math.floor(srcIndex);
              const srcIndexCeil = Math.min(srcIndexFloor + 1, buffer.length - 1);
              const t = srcIndex - srcIndexFloor;
              const interpolated = channelData[srcIndexFloor] * (1 - t) + channelData[srcIndexCeil] * t;
              data[i * numChannels + ch] = interpolated;
            }
          }
        } else {
          data = new Float32Array(buffer.length * numChannels);
          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = buffer.getChannelData(ch);
            for (let i = 0; i < buffer.length; i++) {
              data[i * numChannels + ch] = channelData[i];
            }
          }
        }
        
        const numFrames = data.length / numChannels;
        const ssndSize = numFrames * numChannels * bytesPerSample + 8;
        const commSize = 18;
        const formSize = 4 + 8 + commSize + 8 + ssndSize;
        
        const arrayBuffer = new ArrayBuffer(8 + formSize);
        const view = new DataView(arrayBuffer);
        
        const writeString = (offset, string) => {
          for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
          }
        };
        
        const writeExtended = (offset, rate) => {
          const exponent = 16414;
          view.setUint16(offset, exponent, false);
          view.setUint32(offset + 2, (rate >>> 16) & 0xFFFFFFFF, false);
          view.setUint32(offset + 6, (rate & 0xFFFF) << 16, false);
        };
        
        writeString(0, 'FORM');
        view.setUint32(4, formSize, false);
        writeString(8, 'AIFF');
        writeString(12, 'COMM');
        view.setUint32(16, commSize, false);
        view.setUint16(20, numChannels, false);
        view.setUint32(22, numFrames, false);
        view.setUint16(26, bitDepth, false);
        writeExtended(28, targetRate);
        writeString(38, 'SSND');
        view.setUint32(42, ssndSize, false);
        view.setUint32(46, 0, false);
        view.setUint32(50, 0, false);
        
        let offset = 54;
        for (let i = 0; i < numFrames; i++) {
          for (let ch = 0; ch < numChannels; ch++) {
            const sample = Math.max(-1, Math.min(1, data[i * numChannels + ch]));
            view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, false);
            offset += 2;
          }
        }
        
        return new Blob([arrayBuffer], { type: 'audio/aiff' });
      };

      const playPad = async (index) => {
        if (!pads[index] || mutedPads.has(index)) return;

        const padData = pads[index];
        const audioData = padData.processed || padData.original;
        const blob = new Blob([audioData], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);
        
        const audio = new Audio(url);
        audioElements.current[index] = audio;
        
        setPlayingPads(prev => new Set(prev).add(index));
        
        audio.onended = () => {
          setPlayingPads(prev => {
            const newSet = new Set(prev);
            newSet.delete(index);
            return newSet;
          });
          URL.revokeObjectURL(url);
        };
        
        audio.play();
      };

      const clearPad = (index) => {
        const newPads = [...pads];
        newPads[index] = null;
        setPads(newPads);
        if (selectedPad === index) setSelectedPad(null);
        if (editingPad === index) setEditingPad(null);
      };

      const openEditor = (index) => {
        if (!pads[index]) return;
        setEditingPad(index);
        setEditParams({
          volume: pads[index].volume || 1,
          trimStart: pads[index].trimStart || 0,
          trimEnd: pads[index].trimEnd || 1,
          normalize: pads[index].normalize || false
        });
      };

      const applyEdit = async () => {
        if (editingPad === null) return;
        
        const padData = pads[editingPad];
        const processed = await processAudio(padData, editParams);
        
        const newPads = [...pads];
        newPads[editingPad] = {
          ...padData,
          processed,
          ...editParams
        };
        setPads(newPads);
        setEditingPad(null);
      };

      const toggleMute = (index) => {
        setMutedPads(prev => {
          const newSet = new Set(prev);
          if (newSet.has(index)) {
            newSet.delete(index);
          } else {
            newSet.add(index);
          }
          return newSet;
        });
      };

      const startTrackRecording = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const destNode = audioContextRef.current.createMediaStreamDestination();
          trackStream.current = destNode.stream;
          
          trackRecorder.current = new MediaRecorder(trackStream.current);
          audioChunks.current = [];

          trackRecorder.current.ondataavailable = (e) => {
            audioChunks.current.push(e.data);
          };

          trackRecorder.current.onstop = () => {
            setShowExportModal(true);
          };

          trackRecorder.current.start();
          setIsRecordingTrack(true);
        } catch (err) {
          console.error('Failed to start track recording:', err);
        }
      };

      const stopTrackRecording = () => {
        if (trackRecorder.current && isRecordingTrack) {
          trackRecorder.current.stop();
          setIsRecordingTrack(false);
        }
      };

      const exportTrack = async () => {
        const blob = new Blob(audioChunks.current, { type: 'audio/webm' });
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);
        
        let finalBlob;
        let filename;
        
        if (exportFormat === 'wav') {
          finalBlob = audioBufferToWav(audioBuffer, exportSampleRate);
          filename = `beat_${Date.now()}.wav`;
        } else if (exportFormat === 'aiff') {
          finalBlob = audioBufferToAiff(audioBuffer, exportSampleRate);
          filename = `beat_${Date.now()}.aiff`;
        } else if (exportFormat === 'mp3') {
          finalBlob = audioBufferToWav(audioBuffer, exportSampleRate);
          filename = `beat_${Date.now()}.wav`;
          alert('Note: Direct MP3 encoding requires additional libraries. Exporting as WAV instead.');
        }
        
        const url = URL.createObjectURL(finalBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
        
        setShowExportModal(false);
        audioChunks.current = [];
      };

      // SVG Icons as components
      const Mic = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg>;
      const Upload = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" /></svg>;
      const Circle = () => <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/></svg>;
      const Trash2 = () => <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>;
      const Edit2 = () => <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>;
      const Volume2 = () => <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg>;
      const VolumeX = () => <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" /></svg>;
      const Scissors = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm0-5.758a3 3 0 10-4.243-4.243 3 3 0 004.243 4.243z" /></svg>;
      const X = () => <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>;
      const Download = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>;
      const Volume2Large = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg>;

      return (
        <div className="min-h-screen bg-gradient-to-br from-gray-900 to-gray-800 p-4 pb-48">
          <h1 className="text-3xl font-bold text-white text-center mb-6">Audio Sampler</h1>
          
          {isRecordingTrack && (
            <div className="bg-red-600 text-white text-center py-2 rounded-lg mb-4 animate-pulse font-bold">
              ðŸ”´ RECORDING TRACK
            </div>
          )}

          <div className="grid grid-cols-4 gap-3 max-w-md mx-auto mb-6">
            {pads.map((pad, i) => (
              <div key={i} className="relative">
                <button
                  onClick={() => pad ? playPad(i) : setSelectedPad(i)}
                  className={`
                    w-full aspect-square rounded-xl font-bold text-lg transition-all
                    ${selectedPad === i ? 'ring-4 ring-blue-400' : ''}
                    ${playingPads.has(i) ? 'bg-green-500 scale-95' : 
                      pad ? 'bg-blue-600 hover:bg-blue-500' : 'bg-gray-700 hover:bg-gray-600'}
                    ${mutedPads.has(i) ? 'opacity-50' : ''}
                    text-white shadow-lg active:scale-90
                  `}
                >
                  {i + 1}
                </button>
                
                {pad && (
                  <div className="absolute top-1 right-1 flex gap-1">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        toggleMute(i);
                      }}
                      className="bg-gray-900 bg-opacity-80 p-1 rounded"
                    >
                      {mutedPads.has(i) ? <VolumeX /> : <Volume2 />}
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        openEditor(i);
                      }}
                      className="bg-gray-900 bg-opacity-80 p-1 rounded"
                    >
                      <Edit2 />
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        clearPad(i);
                      }}
                      className="bg-red-600 bg-opacity-80 p-1 rounded"
                    >
                      <Trash2 />
                    </button>
                  </div>
                )}
              </div>
            ))}
          </div>

          <div className="fixed bottom-0 left-0 right-0 bg-gray-800 p-4 shadow-lg">
            <div className="max-w-md mx-auto space-y-3">
              <div className="text-white text-center text-sm">
                {selectedPad !== null ? `Pad ${selectedPad + 1} selected` : 'Select a pad'}
              </div>
              
              <div className="grid grid-cols-2 gap-2">
                <button
                  onClick={isRecording ? stopRecording : startRecording}
                  disabled={selectedPad === null}
                  className={`
                    py-3 rounded-xl font-bold text-white shadow-lg
                    transition-all active:scale-95 flex items-center justify-center gap-2
                    ${isRecording ? 'bg-red-600 animate-pulse' : 'bg-blue-600 hover:bg-blue-500'}
                    disabled:bg-gray-600 disabled:cursor-not-allowed
                  `}
                >
                  <Mic />
                  {isRecording ? 'Stop' : 'Record'}
                </button>

                <button
                  onClick={() => fileInputRef.current?.click()}
                  disabled={selectedPad === null}
                  className="
                    py-3 rounded-xl font-bold text-white shadow-lg
                    bg-purple-600 hover:bg-purple-500
                    transition-all active:scale-95 flex items-center justify-center gap-2
                    disabled:bg-gray-600 disabled:cursor-not-allowed
                  "
                >
                  <Upload />
                  Upload
                </button>
              </div>

              <button
                onClick={isRecordingTrack ? stopTrackRecording : startTrackRecording}
                className={`
                  w-full py-3 rounded-xl font-bold text-white shadow-lg
                  transition-all active:scale-95 flex items-center justify-center gap-2
                  ${isRecordingTrack ? 'bg-red-600 animate-pulse' : 'bg-green-600 hover:bg-green-500'}
                `}
              >
                <Circle />
                {isRecordingTrack ? 'Stop Track Recording' : 'Record Track'}
              </button>
            </div>
          </div>

          <input
            ref={fileInputRef}
            type="file"
            accept="audio/*"
            onChange={handleFileUpload}
            className="hidden"
          />

          {editingPad !== null && (
            <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
              <div className="bg-gray-800 rounded-xl p-6 max-w-md w-full">
                <div className="flex justify-between items-center mb-4">
                  <h2 className="text-xl font-bold text-white">Edit Pad {editingPad + 1}</h2>
                  <button onClick={() => setEditingPad(null)} className="text-white">
                    <X />
                  </button>
                </div>

                <div className="space-y-4">
                  <div>
                    <label className="text-white text-sm block mb-2 flex items-center gap-2">
                      <Volume2Large />
                      Volume: {Math.round(editParams.volume * 100)}%
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="2"
                      step="0.1"
                      value={editParams.volume}
                      onChange={(e) => setEditParams({...editParams, volume: parseFloat(e.target.value)})}
                      className="w-full"
                    />
                  </div>

                  <div>
                    <label className="text-white text-sm block mb-2â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹
              <div>
                <label className="text-white text-sm block mb-2 flex items-center gap-2">
                  <Scissors />
                  Trim End: {Math.round(editParams.trimEnd * 100)}%
                </label>
                <input
                  type="range"
                  min={editParams.trimStart}
                  max="1"
                  step="0.01"
                  value={editParams.trimEnd}
                  onChange={(e) => setEditParams({...editParams, trimEnd: parseFloat(e.target.value)})}
                  className="w-full"
                />
              </div>

              <div className="flex items-center gap-2">
                <input
                  type="checkbox"
                  id="normalize"
                  checked={editParams.normalize}
                  onChange={(e) => setEditParams({...editParams, normalize: e.target.checked})}
                  className="w-5 h-5"
                />
                <label htmlFor="normalize" className="text-white">Normalize Audio</label>
              </div>

              <button
                onClick={applyEdit}
                className="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded-xl transition-all active:scale-95"
              >
                Apply Changes
              </button>
            </div>
          </div>
        </div>
      )}

      {showExportModal && (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
          <div className="bg-gray-800 rounded-xl p-6 max-w-md w-full">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-bold text-white">Export Track</h2>
              <button onClick={() => setShowExportModal(false)} className="text-white">
                <X />
              </button>
            </div>

            <div className="space-y-4">
              <div>
                <label className="text-white text-sm block mb-2">Format</label>
                <select
                  value={exportFormat}
                  onChange={(e) => setExportFormat(e.target.value)}
                  className="w-full bg-gray-700 text-white p-3 rounded-lg"
                >
                  <option value="wav">WAV</option>
                  <option value="aiff">AIFF</option>
                  <option value="mp3">MP3 (as WAV)</option>
                </select>
              </div>

              <div>
                <label className="text-white text-sm block mb-2">Sample Rate</label>
                <select
                  value={exportSampleRate}
                  onChange={(e) => setExportSampleRate(parseInt(e.target.value))}
                  className="w-full bg-gray-700 text-white p-3 rounded-lg"
                >
                  <option value="44100">44.1 kHz</option>
                  <option value="48000">48 kHz</option>
                </select>
              </div>

              <button
                onClick={exportTrack}
                className="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded-xl transition-all active:scale-95 flex items-center justify-center gap-2"
              >
                <Download />
                Export
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

ReactDOM.render(<MobileSampler />, document.getElementById('root'));
